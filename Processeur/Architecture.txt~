

------ Spécifications

Instructions 16 bits
Codés par:
8 bits pour l'instruction - 8 bits pour les arguments
 
les arguments peuvent être de la forme : 
  .reg reg (4 bits pour chaque registre)
  .reg vide (4 bits pour le registre et 4 pour vide)
  .entier 8 bits 







------ Registres

AX et BX sont des registres 8 bits qui permettent toutes les opérations. AX sera particulièrement utilisé pour charger des entiers de la mémoire ou de constantes.
RA est un registre 8 bits qui pointe l'instruction à exécuter au prochain tour
SP est un registre 8 bits qui pointe le dessus de la pile
FP est un registre 8 bits qui pointe le dessous de la pile
FLAGS est un registre de quelques bits qui servira en interne à la gestion des sauts.











------ Instructions


ADD reg1,reg2
  Addition non signée reg1 <- reg1 + reg2
  
ADDS reg1,reg2
  Addition signée reg1 <- reg1 + reg2
  
AND reg1,reg2
  ET logique reg1 <- reg1 & reg2

DIV reg1,reg2
  Division non signée: reg1 <- reg1 / reg2
  Si reg2 = 0 alors renvoie 11111111  
  
JE addr8 (equal)
  Saut à addr8 si FLAG.(0) est à 1, passe à la suite sinon. 
  
JL addr8 (less)
  Saut à addr8 si FLAG.(1) est à 0, passe à la suite sinon.
  
JLE addr8 (less or equal)
  Saut à addr8 si FLAG.(0) est à 1 ou FLAG.(1) est à 0, passe à la suite sinon.    
  
JM addr8 (more)
  Saut à addr8 si FLAG.(1) est à 1 et FLAG.(0) à 0, passe à la suite sinon.  
  
JME addr8 (more or equal)
  Saut à addr8 si FLAG.(1) est à 1, passe à la suite sinon.
  
JMP addr8
  Saut à addr8    

JNE addr8 (not equal)
  Saut à addr8 si FLAG.(0) est à 0, passe à la suite sinon.
  
(LA constante8)
   Sert à charger l'adresse d'une constante dans AX. Surcouche assembleur: fera en fait appel à LI.  

LI int8
  Charge un entier 8 bits dans le registre AX

LM addr8
  Charge un entier 8 bits contenu dans la RAM à l'adresse addr8 dans AX.  
  
MUL reg1,reg2
  Multiplication non signée: reg1 <- reg1 * reg2  
  
MULS reg1,reg2
  Multiplication signée: reg1 <- reg1 * reg2
  
NOT reg1
  opération non bit à bit: reg1 <- non reg1
  
OR reg1,reg2
  OU logique reg1 <- reg1 or reg2
   
SUB reg,reg
  soustraction non signée reg1 <- reg1 - reg2

SUBS reg,reg
  soustraction signée reg1 <- reg1 - reg2
     
SHL reg1,reg2
  décale reg1 de reg2 bits vers la gauche
  
SHR reg1,reg2
  décale reg1 de reg2 bits vers la droite
     
TEST reg1,reg2
  Fait un comparaison de reg1 et de reg2:
  FLAGS.(0) est assigné à 1 s'il y a égalité, 0 sinon.
  FLAGS.(1) est assigné à 1 si reg1 >= reg2, 0 sinon


